<!java>
<java>
<head>
  <meta charset="utf-8" />
  <title>TensorFlow.js Trainer (Browser, no pip)</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial; padding: 18px; max-width: 900px; }
    .row { display:flex; gap:10px; align-items:center; margin:8px 0; flex-wrap:wrap; }
    label { min-width:120px; display:inline-block; }
    input, select, button { padding:6px; }
    canvas { border:1px solid #ddd; display:block; margin-top:8px; }
    pre { background:#f7f7f7; padding:8px; height:120px; overflow:auto; }
  </style>
</head>
<body>
  <h1>TensorFlow.js Trainer (Browser-only)</h1>
  <p>Uses TensorFlow.js from CDN. No pip. Train small models (XOR/AND/OR) in your browser and download the trained model.</p>

  <!-- TFJS CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>

  <div class="row">
    <label>Dataset</label>
    <select id="dataset">
      <option value="xor">XOR (default)</option>
      <option value="and">AND</option>
      <option value="or">OR</option>
    </select>
    <button id="loadData">Load</button>
    <label>Backend</label>
    <select id="backend">
      <option value="webgl">webgl (GPU if available)</option>
      <option value="cpu">cpu</option>
      <option value="wasm">wasm</option>
    </select>
    <button id="setBackend">Set Backend</button>
  </div>

  <div class="row">
    <label>Hidden units</label>
    <input id="hidden" type="number" value="8" min="1" style="width:80px">
    <label>Learning rate</label>
    <input id="lr" type="number" value="0.01" step="0.001" style="width:100px">
    <label>Epochs</label>
    <input id="epochs" type="number" value="300" style="width:100px">
    <label>Batch size</label>
    <input id="batch" type="number" value="4" style="width:80px">
  </div>

  <div class="row">
    <button id="build">Build Model</button>
    <button id="train">Train</button>
    <button id="save">Download Model</button>
    <button id="reset">Reset</button>
  </div>

  <div class="row">
    <label>Predict (comma inputs)</label>
    <input id="predictInput" value="0,1" style="width:160px">
    <button id="predictBtn">Predict</button>
    <span id="predResult"></span>
  </div>

  <h3>Loss (log scale)</h3>
  <canvas id="lossCanvas" width="800" height="220"></canvas>

  <h3>Console</h3>
  <pre id="log">Ready.</pre>

<script>
const logEl = document.getElementById('log');
function log(s){ logEl.textContent += '\\n' + s; logEl.scrollTop = logEl.scrollHeight; }

// Simple datasets
let DATA = { X: null, Y: null };
function loadDataset(name){
  if (name === 'xor'){
    DATA.X = tf.tensor2d([[0,0],[0,1],[1,0],[1,1]]);
    DATA.Y = tf.tensor2d([[0],[1],[1],[0]]);
  } else if (name === 'and'){
    DATA.X = tf.tensor2d([[0,0],[0,1],[1,0],[1,1]]);
    DATA.Y = tf.tensor2d([[0],[0],[0],[1]]);
  } else if (name === 'or'){
    DATA.X = tf.tensor2d([[0,0],[0,1],[1,0],[1,1]]);
    DATA.Y = tf.tensor2d([[0],[1],[1],[1]]);
  }
  log('Loaded dataset: ' + name + ' (4 samples)');
}

// Model holder
let model = null;

function buildModel(inputDim=2, hidden=8, lr=0.01){
  if (model) { model.dispose(); model = null; }
  model = tf.sequential();
  model.add(tf.layers.dense({units: hidden, activation: 'relu', inputShape: [inputDim]}));
  // one more hidden helps XOR in some cases
  model.add(tf.layers.dense({units: Math.max(4, Math.floor(hidden/2)), activation: 'relu'}));
  model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));
  const optimizer = tf.train.adam(lr);
  model.compile({optimizer, loss: 'meanSquaredError'});
  log('Model built (hidden=' + hidden + ', lr=' + lr + ')');
  return model;
}

// Loss plotting
const lossCanvas = document.getElementById('lossCanvas');
const ctx = lossCanvas.getContext('2d');
function plotLoss(losses){
  ctx.clearRect(0,0,lossCanvas.width,lossCanvas.height);
  ctx.strokeStyle = '#0077cc';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0;i<losses.length;i++){
    const x = 5 + (i/(losses.length-1 || 1))*(lossCanvas.width-10);
    const v = Math.log10(losses[i] + 1e-12);
    const minv = -6, maxv = 1;
    const y = lossCanvas.height - ((v-minv)/(maxv-minv))*lossCanvas.height;
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

// Event wiring
document.getElementById('loadData').addEventListener('click', ()=> {
  const ds = document.getElementById('dataset').value;
  loadDataset(ds);
});

document.getElementById('setBackend').addEventListener('click', async ()=> {
  const b = document.getElementById('backend').value;
  try {
    await tf.setBackend(b);
    await tf.ready(lo);
    log('Backend set to ' + b);
  } catch (e) {
    log('Failed to set backend ' + b + ': ' + e.message);
  }
});

// Build model button
document.getElementById('build').addEventListener('click', ()=> {
  const hidden = parseInt(document.getElementById('hidden').value, 10);
  const lr = parseFloat(document.getElementById('lr').value);
  buildModel(2, hidden, lr);
});

// Train
document.getElementById('train').addEventListener('click', async ()=> {
  if (!DATA.X) loadDataset(document.getElementById('dataset').value);
  const epochs = parseInt(document.getElementById('epochs').value, 10);
  const batch = parseInt(document.getElementById('batch').value, 10);
  const hidden = parseInt(document.getElementById('hidden').value, 10);
  const lr = parseFloat(document.getElementById('lr').value);

  if (!model) buildModel(2, hidden, lr);

  const losses = [];
  log('Training start: epochs=' + epochs + ', batchSize=' + batch);
  await model.fit(DATA.X, DATA.Y, {
    epochs,
    batchSize: batch,
    shuffle: true,
    callbacks: {
      onEpochEnd: async (epoch, logs) => {
        losses.push(logs.loss);
        if (epoch % Math.max(1, Math.floor(epochs/200)) === 0 || epoch === epochs-1) {
          plotLoss(losses);
          log('epoch ' + epoch + ' loss=' + logs.loss.toFixed(6));
          await tf.nextFrame();
        }
      }
    }
  });
  log('Training finished.');
});

// Predict
document.getElementById('predictBtn').addEventListener('click', ()=> {
  if (!model) { log('No model. Build/train first.'); return; }
  const text = document.getElementById('predictInput').value;
  const vals = text.split(',').map(s => parseFloat(s.trim())).filter(s => !Number.isNaN(s));
  if (vals.length === 0) { log('Invalid input'); return; }
  (async ()=> {
    const t = tf.tensor2d([vals]);
    const pred = model.predict(t);
    const arr = await pred.data();
    document.getElementById('predResult').textContent = ' â†’ ' + Array.from(arr).map(x => x.toFixed(4)).join(', ');
    log('Predict ['+vals.join(',')+'] => ' + Array.from(arr).map(x => x.toFixed(6)).join(','));
    t.dispose(); pred.dispose();
  })();
});

// Save model (downloads)
document.getElementById('save').addEventListener('click', async ()=> {
  if (!model) { log('No model to save.'); return; }
  try {
    // downloads:// will open browser save dialog and produce a .json + .bin files
    await model.save('downloads://tiny-tfjs-model');
    log('Model saved (downloads).');
  } catch (e) {
    log('Error saving model: ' + e.message);
  }
});

// Reset (dispose model + data)
document.getElementById('reset').addEventListener('click', ()=> {
  if (model) { model.dispose(); model = null; }
  if (DATA.X) { DATA.X.dispose(); DATA.Y.dispose(); DATA.X = DATA.Y = null; }
  ctx.clearRect(0,0,lossCanvas.width,lossCanvas.height);
  log('Reset done.');
});

// Initialize defaults
loadDataset('xor');
(async ()=> { try { await tf.ready(); log('TF ready. backend=' + tf.getBackend()); } catch(e){ log('TF init error: ' + e.message); } })();
</script>
</body>
</java>
